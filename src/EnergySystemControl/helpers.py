import pandas as pd
import numpy as np

import pandas as pd

def resample_with_interpolation(df, target_freq, sim_end: float | None = None, var_type: str = 'extensive'):
    """
    Resample a time series DataFrame to a new frequency, 
    handling both upsampling (with interpolation) and 
    downsampling (with aggregation).

    Parameters
    ----------
    df : pandas.DataFrame
        Input DataFrame with a DatetimeIndex.
    target_freq : str
        New frequency (e.g., "15T", "1H", "1D").
    agg : str or callable, default="mean"
        Aggregation method for downsampling (e.g., "mean", "sum").

    Returns
    -------
    pandas.DataFrame
        Resampled DataFrame.
    NOTE_: generated by ChatGPT
    """
    if not isinstance(df.index, pd.DatetimeIndex):
        raise ValueError("DataFrame must have a DatetimeIndex.")
    
    # Check if repetition is needed
    if sim_end is not None:
        period = df.index[-1] - df.index[0] + (df.index[1] - df.index[0])
        n_repeat = int(np.ceil((pd.to_timedelta(sim_end, 'h')) / period))
        dfs = []
        for i in range(n_repeat):
            df_copy = df.copy()
            df_copy.index = df_copy.index + i * period
            dfs.append(df_copy)
        df = pd.concat(dfs)
        # Trim to exact simulation end
        df = df[df.index <= df.index[0] + pd.to_timedelta(sim_end, 'h')]
    # Check original resolution
    original_freq = pd.infer_freq(df.index)
    if original_freq is None:
        # If infer_freq fails, approximate from median diff
        original_step = df.index.to_series().diff().median()
    else:
        original_step = pd.to_timedelta(pd.tseries.frequencies.to_offset(original_freq))
    # Adding one line to prevent the final dataframe being too short
    if isinstance(df, pd.DataFrame):
        df.loc[df.index[-1] + original_step, :] = df.loc[df.index[-1], :]
    elif isinstance(df, pd.Series):
        df.loc[df.index[-1] + original_step] = df.loc[df.index[-1]]
    target_step = pd.to_timedelta(pd.tseries.frequencies.to_offset(target_freq))

    if target_step >= original_step: # --- Downsampling ---
        match var_type:
            case 'extensive':
                return df.resample(target_freq).agg('sum').values
            case 'intensive':
                return df.resample(target_freq).agg('mean').values
    else:  # --- Upsampling ---
        match var_type:
            case 'extensive':
                output = df.resample(target_freq).ffill()
                output = output * (target_step / original_step)
                return output
            case 'intensive':
                output = df.reindex(pd.date_range(df.index[0], df.index[-1], freq = target_freq, tz=df.index.tz))
                return output.interpolate(method='time').values


def C2K(T):
    return T + 273.15

def K2C(T):
    return T - 273.15

class NodeImbalanceError(Exception):
    pass

class StorageError(Exception):
    pass